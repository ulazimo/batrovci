<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Arrow Escape</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700;900&display=swap');
        
        body { font-family: 'Inter', sans-serif; touch-action: none; user-select: none; -webkit-user-select: none; }
        
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-3px) rotate(-1deg); }
            75% { transform: translateX(3px) rotate(1deg); }
        }
        
        .animate-shake {
            animation: shake 0.3s cubic-bezier(.36,.07,.19,.97) both;
        }

        .block-cell {
            transition: background-color 0.2s;
        }

        /* Smooth transition for flying blocks */
        .block-container {
            transition: transform 0.6s cubic-bezier(0.5, 0, 0.2, 1), opacity 0.6s ease-in;
        }

        /* Custom scrollbar for select */
        select {
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            background-color: transparent;
            cursor: pointer;
        }
    </style>
</head>
<body class="bg-slate-950 text-slate-100 overflow-hidden flex flex-col h-screen relative">

    <!-- Particles Container -->
    <canvas id="particleCanvas" class="absolute inset-0 pointer-events-none z-50"></canvas>

    <!-- Header -->
    <div class="pt-6 pb-2 px-6 w-full max-w-md mx-auto flex justify-between items-end z-10 shrink-0">
        <div>
            <div class="text-xs font-bold text-slate-500 uppercase tracking-widest mb-1 flex items-center gap-1">
                LEVEL 
                <div class="relative inline-block ml-1">
                    <select id="levelSelect" onchange="game.startLevel(parseInt(this.value))" class="font-bold text-indigo-400 bg-slate-900 border border-slate-700 rounded px-2 py-0.5 text-xs focus:outline-none focus:border-indigo-500">
                        <!-- Options generated by JS -->
                    </select>
                </div>
            </div>
            <h1 class="text-2xl font-black text-white tracking-tight leading-none">
                BLOCK <span class="text-indigo-500">AWAY</span>
            </h1>
        </div>
        <div class="flex items-center gap-2 bg-slate-900 px-3 py-1.5 rounded-full border border-slate-800">
            <!-- Heart Icon -->
            <svg class="w-4 h-4 text-rose-500" id="heartIcon" viewBox="0 0 24 24" fill="currentColor" stroke="none">
                <path d="M19 14c1.49-1.46 3-3.21 3-5.5A5.5 5.5 0 0 0 16.5 3c-1.76 0-3 .5-4.5 2-1.5-1.5-2.74-2-4.5-2A5.5 5.5 0 0 0 2 8.5c0 2.3 1.5 4.05 3 5.5l7 7Z"/>
            </svg>
            <span id="livesDisplay" class="font-bold text-white">5</span>
        </div>
    </div>

    <!-- Game Area -->
    <div class="flex-1 flex flex-col items-center justify-center p-4 w-full max-w-lg mx-auto relative">
        
        <!-- Progress Bar -->
        <div class="w-full h-1 bg-slate-800 rounded-full mb-6 overflow-hidden shrink-0">
            <div id="progressBar" class="h-full bg-indigo-500 transition-all duration-500" style="width: 0%"></div>
        </div>

        <!-- Board Container -->
        <div class="relative p-2 rounded-xl bg-slate-900/50 border border-slate-800 w-full aspect-square shadow-2xl">
            
            <!-- Overlays (Win/Loss) -->
            <div id="overlay" class="absolute inset-0 z-50 flex flex-col items-center justify-center bg-slate-950/90 rounded-xl backdrop-blur-sm transition-opacity duration-300 hidden opacity-0">
                <div id="overlayContent" class="flex flex-col items-center text-center animate-in fade-in zoom-in duration-300">
                    <!-- Content injected via JS -->
                </div>
            </div>

            <!-- Grid Container -->
            <div id="gameBoard" class="w-full h-full relative">
                <!-- Floor Grid (Background) -->
                <div id="gridBackground" class="absolute inset-0 grid gap-0.5 opacity-30 pointer-events-none">
                    <!-- Cells injected via JS -->
                </div>
                
                <!-- Blocks Container -->
                <div id="blocksContainer" class="absolute inset-0 w-full h-full">
                    <!-- Blocks injected via JS -->
                </div>
            </div>
        </div>

        <!-- Footer Controls -->
        <div class="mt-6 flex gap-4 shrink-0">
            <button onclick="game.restartLevel()" class="p-3 bg-slate-800 rounded-xl text-slate-400 hover:text-white hover:bg-slate-700 shadow-lg transition-colors active:scale-95">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 12"/><path d="M3 3v9h9"/></svg>
            </button>
            <button onclick="game.showRules()" class="p-3 bg-slate-800 rounded-xl text-slate-400 hover:text-white hover:bg-slate-700 shadow-lg transition-colors active:scale-95">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/><path d="M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3"/><path d="M12 17h.01"/></svg>
            </button>
        </div>
    </div>

    <!-- Rules Modal -->
    <div id="rulesModal" class="fixed inset-0 z-[60] flex items-end sm:items-center justify-center sm:p-4 bg-black/80 backdrop-blur-sm hidden">
        <div class="bg-slate-800 sm:rounded-2xl rounded-t-2xl max-w-sm w-full p-6 shadow-2xl border border-slate-700 animate-in slide-in-from-bottom duration-300">
            <h2 class="text-xl font-black text-white mb-4">HOW TO PLAY</h2>
            <div class="space-y-3 text-slate-300 text-sm">
                <p>Tap blocks to fly them off screen.</p>
                <p>Blocks have <strong class="text-indigo-400">Complex Shapes</strong> (L, T, Square)!</p>
                <p>Clear the path for the ENTIRE shape.</p>
            </div>
            <button onclick="document.getElementById('rulesModal').classList.add('hidden')" class="mt-6 w-full py-3 bg-white text-slate-900 font-bold rounded-xl shadow-lg active:scale-95 transition-transform">GOT IT</button>
        </div>
    </div>

<script>
/**
 * ARROW ESCAPE - GAME LOGIC
 */

// --- Constants & Types ---
const MAX_LIVES = 5;

const SHAPE_TEMPLATES = [
  [{r:0,c:0}, {r:0,c:-1}, {r:0,c:-2}], // I3
  [{r:0,c:0}, {r:0,c:-1}, {r:0,c:-2}, {r:0,c:-3}], // I4
  [{r:0,c:0}, {r:0,c:-1}, {r:1,c:-1}], // L3
  [{r:0,c:0}, {r:0,c:-1}, {r:-1,c:-1}], // J3
  [{r:0,c:0}, {r:0,c:-1}, {r:1,c:-1}, {r:0,c:-2}], // L4 Long
  [{r:0,c:0}, {r:0,c:-1}, {r:1,c:0}, {r:1,c:-1}], // O4 (Square)
  [{r:0,c:0}, {r:0,c:-1}, {r:-1,c:-1}, {r:1,c:-1}], // T4
  [{r:0,c:0}, {r:0,c:-1}, {r:1,c:-1}, {r:1,c:-2}], // S4
];

// --- Helpers ---

const getDelta = (dir) => {
    switch (dir) {
        case 'UP': return { dr: -1, dc: 0 };
        case 'DOWN': return { dr: 1, dc: 0 };
        case 'LEFT': return { dr: 0, dc: -1 };
        case 'RIGHT': return { dr: 0, dc: 1 };
    }
};

const rotatePoint = (p) => ({ r: p.c, c: -p.r });

const transformShape = (template, dir) => {
    let points = [...template];
    let rotations = 0;
    if (dir === 'DOWN') rotations = 1;
    if (dir === 'LEFT') rotations = 2;
    if (dir === 'UP') rotations = 3;
    for (let i = 0; i < rotations; i++) {
        points = points.map(rotatePoint);
    }
    return points;
};

const getOccupiedCells = (block) => {
    return block.shape.map(p => ({
        r: block.row + p.r,
        c: block.col + p.c
    }));
};

const hasPoint = (shape, r, c) => shape.some(p => p.r === r && p.c === c);

// --- Game Engine ---

class Game {
    constructor() {
        this.blocks = [];
        this.lives = MAX_LIVES;
        this.level = 1;
        this.gridSize = 10;
        this.state = 'playing'; // playing, won, lost
        this.particles = [];
        
        // DOM Elements
        this.elBoard = document.getElementById('gameBoard');
        this.elBlocks = document.getElementById('blocksContainer');
        this.elGridBg = document.getElementById('gridBackground');
        this.elOverlay = document.getElementById('overlay');
        this.elOverlayContent = document.getElementById('overlayContent');
        this.elLives = document.getElementById('livesDisplay');
        this.elLevelSelect = document.getElementById('levelSelect');
        this.elProgress = document.getElementById('progressBar');
        this.canvas = document.getElementById('particleCanvas');
        this.ctx = this.canvas.getContext('2d');

        // Populate Level Select
        this.initLevelSelect();

        // Initial Setup
        this.initGrid();
        this.resizeCanvas();
        window.addEventListener('resize', () => this.resizeCanvas());
        
        // Start Loop
        this.startLevel(1);
        this.loop();
    }

    initLevelSelect() {
        for (let i = 1; i <= 50; i++) {
            const opt = document.createElement('option');
            opt.value = i;
            opt.innerText = i;
            this.elLevelSelect.appendChild(opt);
        }
    }

    resizeCanvas() {
        this.canvas.width = window.innerWidth;
        this.canvas.height = window.innerHeight;
    }

    initGrid() {
        this.elGridBg.style.gridTemplateColumns = `repeat(${this.gridSize}, 1fr)`;
        this.elGridBg.style.gridTemplateRows = `repeat(${this.gridSize}, 1fr)`;
        this.elGridBg.innerHTML = '';
        for (let i = 0; i < this.gridSize * this.gridSize; i++) {
            const div = document.createElement('div');
            div.className = 'bg-slate-800 rounded-sm';
            this.elGridBg.appendChild(div);
        }
    }

    startLevel(lvl) {
        this.level = lvl;
        if (this.elLevelSelect) this.elLevelSelect.value = lvl;
        
        if (lvl === 1) this.lives = MAX_LIVES;
        this.state = 'playing';
        
        // Dynamic Grid Size
        if (lvl < 5) this.gridSize = 10;
        else if (lvl < 10) this.gridSize = 12;
        else this.gridSize = 15;

        // Re-init grid UI to match new size
        this.initGrid();

        this.blocks = this.generateLevel(this.gridSize);
        this.totalBlocksStart = this.blocks.length;
        
        this.updateUI();
        this.renderBlocks();
        this.hideOverlay();
    }

    restartLevel() {
        this.startLevel(this.level);
    }

    // --- Logic ---

    isPathClear(block, allBlocks) {
        const { dr, dc } = getDelta(block.dir);
        const myCells = getOccupiedCells(block);

        for (const cell of myCells) {
            let r = cell.r + dr;
            let c = cell.c + dc;
            
            while (r >= 0 && r < this.gridSize && c >= 0 && c < this.gridSize) {
                const isBlocked = allBlocks.some(other => {
                    if (other.id === block.id) return false;
                    if (other.state === 'flying') return false;
                    const otherCells = getOccupiedCells(other);
                    return otherCells.some(oc => oc.r === r && oc.c === c);
                });

                if (isBlocked) return false;
                r += dr;
                c += dc;
            }
        }
        return true;
    }

    isSolvable(blocks) {
        let remaining = [...blocks];
        let moved = true;
        while (moved && remaining.length > 0) {
            moved = false;
            const toRemove = [];
            for (const block of remaining) {
                if (this.isPathClear(block, remaining)) {
                    toRemove.push(block.id);
                    moved = true;
                }
            }
            if (moved) {
                remaining = remaining.filter(b => !toRemove.includes(b.id));
            }
        }
        return remaining.length === 0;
    }

    generateLevel(size) {
        let attempts = 0;
        
        // Difficulty Tuning - REVISED
        // Previously density was up to 0.85 which caused the single-block bug.
        // Random generation is very inefficient at densities > 0.5 for complex shapes.
        // We cap density at 0.55 for the largest grids to ensure solvability.
        
        let density = 0.15; 
        let allowedTemplates = [0, 1]; // I3, I4

        // Increase Density & Complexity with levels
        if (this.level > 1) { density = 0.25; }
        if (this.level > 3) { density = 0.35; allowedTemplates = [0, 1, 2, 3]; } // Add L3, J3
        if (this.level > 5) { density = 0.45; allowedTemplates = [0, 1, 2, 3, 4, 5]; } // Add L4, Square
        if (this.level > 7) { density = 0.50; allowedTemplates = [0, 1, 2, 3, 4, 5, 6, 7]; } // All shapes
        if (this.level > 9) { density = 0.55; } // Crowded but solvable

        const maxAttempts = 1000; 

        while (attempts < maxAttempts) {
            // Adaptive density fallback: if we fail often, reduce density for this attempt
            let currentTargetDensity = density;
            if (attempts > 200) currentTargetDensity *= 0.9;
            if (attempts > 500) currentTargetDensity *= 0.8;

            const targetCells = Math.floor(size * size * currentTargetDensity);

            const blocks = [];
            let idCounter = 0;
            const occupiedSet = new Set();
            let currentCells = 0;

            for (let i = 0; i < 500; i++) { // Placement attempts loop
                if (currentCells >= targetCells) break;

                const dirs = ['UP', 'DOWN', 'LEFT', 'RIGHT'];
                const dir = dirs[Math.floor(Math.random() * dirs.length)];
                
                const tIdx = allowedTemplates[Math.floor(Math.random() * allowedTemplates.length)];
                const template = SHAPE_TEMPLATES[tIdx];
                
                const shape = transformShape(template, dir);
                const r = Math.floor(Math.random() * size);
                const c = Math.floor(Math.random() * size);

                const candidateCells = shape.map(p => ({ r: r + p.r, c: c + p.c }));
                
                const inBounds = candidateCells.every(cell => cell.r >= 0 && cell.r < size && cell.c >= 0 && cell.c < size);
                if (!inBounds) continue;

                const overlap = candidateCells.some(cell => occupiedSet.has(`${cell.r}-${cell.c}`));
                if (overlap) continue;

                blocks.push({
                    id: `b-${idCounter++}`,
                    row: r, col: c, dir, shape,
                    state: 'idle',
                    colorHue: Math.floor(Math.random() * 360)
                });

                candidateCells.forEach(cell => occupiedSet.add(`${cell.r}-${cell.c}`));
                currentCells += candidateCells.length;
            }

            if (blocks.length > 3 && this.isSolvable(blocks)) {
                return blocks;
            }
            attempts++;
        }
        
        // Emergency Fallback: Generate a very simple solvable level instead of 1 block
        // This ensures the game is always playable even if generation times out
        const simpleBlock = { 
            id: 'f1', 
            row: Math.floor(size/2), 
            col: Math.floor(size/2), 
            dir: 'RIGHT', 
            shape: transformShape(SHAPE_TEMPLATES[0], 'RIGHT'), 
            state: 'idle', 
            colorHue: 0 
        };
         const simpleBlock2 = { 
            id: 'f2', 
            row: Math.floor(size/2) - 2, 
            col: Math.floor(size/2), 
            dir: 'DOWN', 
            shape: transformShape(SHAPE_TEMPLATES[2], 'DOWN'), 
            state: 'idle', 
            colorHue: 50 
        };
        return [simpleBlock, simpleBlock2];
    }

    handleBlockClick(id, mouseX, mouseY) {
        if (this.state !== 'playing') return;

        const block = this.blocks.find(b => b.id === id);
        if (!block || block.state !== 'idle') return;

        const clear = this.isPathClear(block, this.blocks);
        const isBlocked = !clear;

        // Visuals
        this.spawnParticles(mouseX, mouseY, isBlocked ? '#f43f5e' : '#6366f1');

        if (clear) {
            // Success
            block.state = 'flying';
            this.updateBlockVisual(block);
            
            // Remove after animation
            setTimeout(() => {
                this.blocks = this.blocks.filter(b => b.id !== id);
                this.checkWin();
                this.updateUI();
            }, 600);
        } else {
            // Failure
            this.lives = Math.max(0, this.lives - 1);
            block.state = 'blocked';
            this.updateBlockVisual(block);
            this.updateUI();
            
            // Reset state
            setTimeout(() => {
                if (block.state === 'blocked') block.state = 'idle';
                this.updateBlockVisual(block);
            }, 400);

            if (this.lives === 0) this.gameOver();
        }
    }

    checkWin() {
        const remaining = this.blocks.filter(b => b.state !== 'flying');
        if (remaining.length === 0) {
            this.state = 'won';
            this.showOverlay('won');
        }
    }

    gameOver() {
        this.state = 'lost';
        this.showOverlay('lost');
    }

    // --- Rendering ---

    updateUI() {
        this.elLives.textContent = this.lives;
        this.elLives.className = `font-bold ${this.lives < 2 ? 'text-rose-400' : 'text-white'}`;
        // Level display is now the select box value, handled in startLevel
        
        const activeBlocks = this.blocks.filter(b => b.state !== 'flying').length;
        const progress = Math.max(0, 100 - (activeBlocks / this.totalBlocksStart) * 100);
        this.elProgress.style.width = `${progress}%`;
    }

    renderBlocks() {
        this.elBlocks.innerHTML = '';
        const cellSize = 100 / this.gridSize; // Dynamic percentage based on grid size

        this.blocks.forEach(block => {
            const container = document.createElement('div');
            container.id = `block-${block.id}`;
            container.className = 'absolute top-0 left-0 w-full h-full pointer-events-none block-container';
            container.style.zIndex = block.state === 'flying' ? '50' : '20';

            // Render Cells
            block.shape.forEach((pt, idx) => {
                const cell = document.createElement('div');
                cell.className = 'absolute pointer-events-auto cursor-pointer transition-transform';
                
                // Calculate position using dynamic cell size
                const top = (block.row + pt.r) * cellSize;
                const left = (block.col + pt.c) * cellSize;
                
                cell.style.top = `${top}%`;
                cell.style.left = `${left}%`;
                cell.style.width = `${cellSize}%`;
                cell.style.height = `${cellSize}%`;
                
                // Neighbors
                const hasTop = hasPoint(block.shape, pt.r - 1, pt.c);
                const hasBottom = hasPoint(block.shape, pt.r + 1, pt.c);
                const hasLeft = hasPoint(block.shape, pt.r, pt.c - 1);
                const hasRight = hasPoint(block.shape, pt.r, pt.c + 1);

                cell.style.paddingTop = hasTop ? '0' : '2px';
                cell.style.paddingBottom = hasBottom ? '0' : '2px';
                cell.style.paddingLeft = hasLeft ? '0' : '2px';
                cell.style.paddingRight = hasRight ? '0' : '2px';

                const inner = document.createElement('div');
                inner.className = 'block-cell w-full h-full flex items-center justify-center bg-indigo-500';
                
                inner.style.borderTopLeftRadius = (!hasTop && !hasLeft) ? '0.5rem' : '0';
                inner.style.borderTopRightRadius = (!hasTop && !hasRight) ? '0.5rem' : '0';
                inner.style.borderBottomLeftRadius = (!hasBottom && !hasLeft) ? '0.5rem' : '0';
                inner.style.borderBottomRightRadius = (!hasBottom && !hasRight) ? '0.5rem' : '0';
                
                inner.style.borderTop = hasTop ? 'none' : '1px solid rgba(255,255,255,0.3)';
                inner.style.borderLeft = hasLeft ? 'none' : '1px solid rgba(255,255,255,0.3)';
                inner.style.borderBottom = hasBottom ? 'none' : '1px solid rgba(0,0,0,0.3)';
                inner.style.borderRight = hasRight ? 'none' : '1px solid rgba(0,0,0,0.3)';

                cell.addEventListener('mousedown', (e) => this.handleBlockClick(block.id, e.clientX, e.clientY));

                if (pt.r === 0 && pt.c === 0) {
                    const arrow = document.createElement('div');
                    let rot = 0;
                    if (block.dir === 'DOWN') rot = 90;
                    if (block.dir === 'LEFT') rot = 180;
                    if (block.dir === 'UP') rot = -90;
                    
                    arrow.innerHTML = `<svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="4" stroke-linecap="round" stroke-linejoin="round" style="transform: rotate(${rot}deg)"><path d="M5 12h14"/><path d="m12 5 7 7-7 7"/></svg>`;
                    arrow.className = 'drop-shadow-md relative z-10';
                    inner.appendChild(arrow);
                }

                cell.appendChild(inner);
                container.appendChild(cell);
            });

            this.elBlocks.appendChild(container);
        });
    }

    updateBlockVisual(block) {
        const container = document.getElementById(`block-${block.id}`);
        if (!container) return;

        if (block.state === 'blocked') {
            container.classList.add('animate-shake');
            const cells = container.querySelectorAll('.block-cell');
            cells.forEach(c => {
                c.classList.remove('bg-indigo-500');
                c.classList.add('bg-rose-500');
            });
        } else if (block.state === 'idle') {
            container.classList.remove('animate-shake');
            const cells = container.querySelectorAll('.block-cell');
            cells.forEach(c => {
                c.classList.remove('bg-rose-500');
                c.classList.add('bg-indigo-500');
            });
        }

        if (block.state === 'flying') {
            container.style.opacity = '0';
            const dist = '120vh';
            if (block.dir === 'UP') container.style.transform = `translateY(-${dist})`;
            if (block.dir === 'DOWN') container.style.transform = `translateY(${dist})`;
            if (block.dir === 'LEFT') container.style.transform = `translateX(-${dist})`;
            if (block.dir === 'RIGHT') container.style.transform = `translateX(${dist})`;
        }
    }

    showOverlay(type) {
        this.elOverlay.classList.remove('hidden', 'opacity-0');
        this.elOverlay.classList.add('opacity-100');
        
        if (type === 'won') {
            this.elOverlayContent.innerHTML = `
                <svg class="w-20 h-20 text-yellow-400 mb-4 drop-shadow-[0_0_15px_rgba(250,204,21,0.5)]" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="M6 9H4.5a2.5 2.5 0 0 1 0-5H6"/><path d="M18 9h1.5a2.5 2.5 0 0 0 0-5H18"/><path d="M4 22h16"/><path d="M10 14.66V17c0 .55-.47.98-.97 1.21C7.85 18.75 7 20.24 7 22"/><path d="M14 14.66V17c0 .55.47.98.97 1.21C16.15 18.75 17 20.24 17 22"/><path d="M18 2H6v7a6 6 0 0 0 12 0V2Z"/></svg>
                <h2 class="text-3xl font-black text-white mb-1">CLEARED!</h2>
                <button onclick="game.startLevel(game.level + 1)" class="mt-8 px-8 py-3 bg-emerald-500 hover:bg-emerald-400 text-white font-bold rounded-xl shadow-lg active:scale-95 transition-transform flex items-center gap-2">
                    NEXT LEVEL <svg width="18" height="18" viewBox="0 0 24 24" fill="currentColor"><polygon points="5 3 19 12 5 21 5 3"></polygon></svg>
                </button>
            `;
        } else {
            this.elOverlayContent.innerHTML = `
                <div class="relative mb-4">
                     <svg class="w-24 h-24 text-rose-500 opacity-20" viewBox="0 0 24 24" fill="currentColor"><path d="M19 14c1.49-1.46 3-3.21 3-5.5A5.5 5.5 0 0 0 16.5 3c-1.76 0-3 .5-4.5 2-1.5-1.5-2.74-2-4.5-2A5.5 5.5 0 0 0 2 8.5c0 2.3 1.5 4.05 3 5.5l7 7Z"/></svg>
                     <svg class="w-12 h-12 text-rose-500 absolute inset-0 m-auto" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"><path d="M18 6 6 18"/><path d="m6 6 12 12"/></svg>
                </div>
                <h2 class="text-3xl font-black text-white mb-6">OUT OF MOVES</h2>
                <button onclick="game.restartLevel()" class="px-8 py-3 bg-indigo-600 hover:bg-indigo-500 text-white font-bold rounded-xl shadow-lg active:scale-95 transition-transform flex items-center gap-2">
                    TRY AGAIN <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 12"/><path d="M3 3v9h9"/></svg>
                </button>
            `;
        }
    }

    hideOverlay() {
        this.elOverlay.classList.add('hidden', 'opacity-0');
        this.elOverlay.classList.remove('opacity-100');
    }

    showRules() {
        document.getElementById('rulesModal').classList.remove('hidden');
    }

    // --- Particles ---

    spawnParticles(x, y, color) {
        for (let i = 0; i < 12; i++) {
            this.particles.push({
                x, y,
                vx: (Math.random() - 0.5) * 15,
                vy: (Math.random() - 0.5) * 15,
                life: 1.0,
                color
            });
        }
    }

    loop() {
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        
        // Update & Draw Particles
        for (let i = this.particles.length - 1; i >= 0; i--) {
            const p = this.particles[i];
            p.x += p.vx;
            p.y += p.vy;
            p.vy += 0.5; // Gravity
            p.life -= 0.05;

            if (p.life <= 0) {
                this.particles.splice(i, 1);
                continue;
            }

            this.ctx.globalAlpha = p.life;
            this.ctx.fillStyle = p.color;
            this.ctx.beginPath();
            this.ctx.arc(p.x, p.y, 4, 0, Math.PI * 2);
            this.ctx.fill();
        }
        
        requestAnimationFrame(() => this.loop());
    }
}

// Start Game
const game = new Game();

</script>

<!-- FIREBASE TRACKING -->
<script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
    import { getFirestore, doc, updateDoc, increment } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";
    import { getAuth, signInAnonymously, setPersistence, inMemoryPersistence } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js";

    const firebaseConfig = {
        apiKey: "AIzaSyC2RSC711FagoP5XsODIFfLMMZUX6Up-xM",
        authDomain: "prototypes-7691b.firebaseapp.com",
        projectId: "prototypes-7691b",
        storageBucket: "prototypes-7691b.firebasestorage.app",
        messagingSenderId: "263652926534",
        appId: "1:263652926534:web:9af3c4ce63aab78f0f9647",
        measurementId: "G-1X91H99N2G"
    };

    const GAME_ID = 'block-away'; 

    let db;
    let auth;
    let currentUser = null;

    async function initFirebase() {
        try {
            if (firebaseConfig.apiKey !== "YOUR_API_KEY") {
                const app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                auth = getAuth(app);
                
                // Crucial: Set inMemory persistence for iframe/preview support
                try {
                    await setPersistence(auth, inMemoryPersistence);
                } catch (e) {
                    console.warn("Persistence set warning", e);
                }

                const userCredential = await signInAnonymously(auth);
                currentUser = userCredential.user;
                console.log("Stats tracking active");

                const statsRef = doc(db, "game_stats", GAME_ID);
                updateDoc(statsRef, {
                    plays: increment(1)
                }).catch(e => console.log("Stats error:", e));
            }
        } catch (e) { console.error("Tracking Error - check console", e); }
    }

    initFirebase();

    let startTime = Date.now();

    function saveTime() {
        if (!db || !currentUser) return; // Guard check
        const timeSpentSeconds = Math.floor((Date.now() - startTime) / 1000);
        if (timeSpentSeconds > 0) {
            const statsRef = doc(db, "game_stats", GAME_ID);
            updateDoc(statsRef, {
                timePlayed: increment(timeSpentSeconds)
            }).catch(e => console.log("Stats error:", e));
            startTime = Date.now();
        }
    }

    window.addEventListener("visibilitychange", () => {
        if (document.visibilityState === 'hidden') saveTime();
        else startTime = Date.now();
    });
    window.addEventListener("beforeunload", saveTime);
</script>
</body>
</html>